<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Boundless Connect the Dots - WebXR Christmas Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js"
    }
  }
  </script>

  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f1419, #1a2332, #2d4a5c);
    }
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1;
    }
    #start-button {
      padding: 14px 28px;
      font-size: 20px;
      background: linear-gradient(135deg, rgba(34, 139, 34, 0.8), rgba(0, 100, 0, 0.9));
      color: white;
      border: none;
      border-radius: 30px;
      box-shadow: 0 4px 15px rgba(34, 139, 34, 0.5), 0 0 20px rgba(34, 139, 34, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    #start-button:hover {
      transform: translateY(-3px) scale(1.03);
      box-shadow: 0 6px 20px rgba(34, 139, 34, 0.6), 0 0 30px rgba(34, 139, 34, 0.4);
    }
    #status {
      margin-top: 15px;
      font-size: 16px;
      background: rgba(10, 20, 30, 0.6);
      color: white;
      padding: 12px 18px;
      border-radius: 12px;
      display: none;
      backdrop-filter: blur(8px);
      box-shadow: 0 4px 10px rgba(0,0,0,0.2), inset 0 0 10px rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.1);
    }
    .webxr-hidden {
      display: none !important;
    }
    .exit-ar { 
      position: fixed; 
      top: 20px; 
      right: 20px; 
      background: rgba(255, 255, 255, 0.25); 
      color: white; 
      border: none; 
      border-radius: 50%; 
      width: 50px; 
      height: 50px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 24px; 
      cursor: pointer; 
      backdrop-filter: blur(5px); 
      box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
      z-index: 1000; 
      display: none; 
    }
    .xr-active .exit-ar { 
      display: flex; 
    }
  </style>
</head>
<body>
  <div id="overlay">
            <button id="start-button">Start Boundless Connect the Dots</button>
    <div id="status"></div>
  </div>
  
  <button class="exit-ar" id="exit-ar">Ã—</button>
  
  <audio id="connect-sound" preload="auto">
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmWNhELOc/mP2Y8HLb/zNHGQlI+O3+7IXgcCGVJfvj/3XXwcOnjO8OWLOAgZesHq4Zr" type="audio/wav">
  </audio>
  
  <audio id="complete-sound" preload="auto">
    <source src="data:audio/wav;base64,UklGRo4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWoCAAC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4" type="audio/wav">
  </audio>
  
  <script type="module">
    import * as THREE from 'three';

    let camera, scene, renderer;
    let activeController;
    let controllers = [];
    let activeControllerIndex = 0;
    
    // Game state
    let dots = [];
    let lines = [];
    let connectedDots = [];
    let currentDotIndex = 0;
    let gameComplete = false;
    let christmasTree = null;
    let clock = new THREE.Clock();
    let xrSession = null;
    
    // UI elements
    let instructionPanel;
    let progressText;
    
    // Christmas tree dot positions - forming a tree shape (lowered and closer)
    const treePattern = [
      // Star at top
      { x: 0, y: 0.8, z: -1.2, id: 0 },
      
      // Top triangle
      { x: -0.15, y: 0.6, z: -1.2, id: 1 },
      { x: 0.15, y: 0.6, z: -1.2, id: 2 },
      { x: 0, y: 0.4, z: -1.2, id: 3 },
      
      // Middle triangle
      { x: -0.3, y: 0.3, z: -1.2, id: 4 },
      { x: 0.3, y: 0.3, z: -1.2, id: 5 },
      { x: 0, y: 0, z: -1.2, id: 6 },
      
      // Bottom triangle  
      { x: -0.45, y: -0.1, z: -1.2, id: 7 },
      { x: 0.45, y: -0.1, z: -1.2, id: 8 },
      { x: 0, y: -0.4, z: -1.2, id: 9 },
      
      // Trunk
      { x: -0.1, y: -0.5, z: -1.2, id: 10 },
      { x: 0.1, y: -0.5, z: -1.2, id: 11 },
      { x: 0.1, y: -0.7, z: -1.2, id: 12 },
      { x: -0.1, y: -0.7, z: -1.2, id: 13 }
    ];
    
    // Connection order for the Christmas tree
    const connectionOrder = [0, 1, 3, 2, 0, 4, 6, 5, 4, 7, 9, 8, 7, 10, 13, 12, 11, 10];
    
    function updateStatus(message) {
      const statusElement = document.getElementById('status');
      statusElement.style.display = 'block';
      statusElement.textContent = message;
      console.log('Status:', message);
      
      if (!message.includes('error') && !message.includes('Failed')) {
        setTimeout(() => { statusElement.style.display = 'none'; }, 5000);
      }
    }
    
    init();

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x001122, 0.02);
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
      directionalLight.position.set(2, 2, 2);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Magical lighting
      const pointLight1 = new THREE.PointLight(0xffd700, 1, 3);
      pointLight1.position.set(-1, 1, -1);
      scene.add(pointLight1);
      
      const pointLight2 = new THREE.PointLight(0xff6b6b, 1, 3);
      pointLight2.position.set(1, 1, -1);
      scene.add(pointLight2);

      document.getElementById('start-button').addEventListener('click', startARSession);
      document.getElementById('exit-ar').addEventListener('click', endARSession);
      window.addEventListener('resize', onWindowResize);
    }

    async function startARSession() {
      if (!navigator.xr) {
        updateStatus('WebXR not supported on this device');
        return;
      }
      
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (supported) {
          const sessionInit = {
            requiredFeatures: ['local-floor'],
            optionalFeatures: ['unbounded', 'dom-overlay', 'hand-tracking'],
            domOverlay: { root: document.body }
          };
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          onSessionStarted(session);
        } else {
          updateStatus('WebXR AR session is not supported on this device.');
        }
      } catch (error) {
        updateStatus('Failed to start AR session: ' + error.message);
      }
    }

    function hideUIElements() {
      document.getElementById('overlay').classList.add('webxr-hidden');
    }

    function showUIElements() {
      document.getElementById('overlay').classList.remove('webxr-hidden');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    async function onSessionStarted(session) {
      xrSession = session;
      document.getElementById('start-button').style.display = 'none';
      document.body.classList.add('xr-active');
      
      // Try to get unbounded reference space for boundless AR
      let referenceSpace;
      try {
        referenceSpace = await session.requestReferenceSpace('unbounded');
        updateStatus('Boundless AR mode active! Walk freely to reach all dots.');
      } catch (error) {
        try {
          referenceSpace = await session.requestReferenceSpace('local-floor');
          updateStatus('AR mode active with floor tracking.');
        } catch (error2) {
          referenceSpace = await session.requestReferenceSpace('local');
          updateStatus('AR mode active.');
        }
      }
      
      renderer.xr.setReferenceSpace(referenceSpace);
      renderer.xr.setSession(session);
      hideUIElements();

      updateStatus('Creating magical dot pattern...');

      createGameEnvironment();
      createDots();
      create3DUI();
      setupController(session);

      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnd);

      updateStatus('Walk around freely! No boundaries - reach every dot!');
    }

    function endARSession() {
      if (xrSession) {
        xrSession.end();
      }
    }

    function onSessionEnd() {
      document.body.classList.remove('xr-active');
      showUIElements();
      document.getElementById('start-button').style.display = 'block';
      
      clearScene();
      renderer.setAnimationLoop(null);
      xrSession = null;
    }

    function clearScene() {
      // Clean up all game objects
      dots.forEach(dot => {
        if (dot.geometry) dot.geometry.dispose();
        if (dot.material) dot.material.dispose();
        scene.remove(dot);
      });
      dots = [];
      
      lines.forEach(line => {
        if (line.geometry) line.geometry.dispose();
        if (line.material) line.material.dispose();
        scene.remove(line);
      });
      lines = [];
      
      if (christmasTree) {
        scene.remove(christmasTree);
        christmasTree = null;
      }
      
      if (instructionPanel) {
        scene.remove(instructionPanel);
        instructionPanel = null;
      }
      
      // Reset game state
      connectedDots = [];
      currentDotIndex = 0;
      gameComplete = false;
    }

    function createGameEnvironment() {
      // Add some floating particles for ambiance - positioned closer and at reachable heights
      for (let i = 0; i < 30; i++) {
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.005, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6
          })
        );
        particle.position.set(
          (Math.random() - 0.5) * 2.5, // Reduced spread from 4 to 2.5
          Math.random() * 1.5 - 0.5, // Height from -0.5 to 1.0 (reachable)
          -2 - Math.random() * 1 // Closer depth: -2 to -3
        );
        scene.add(particle);
      }
    }

    function createDots() {
      treePattern.forEach(dotPos => {
        const dot = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 16, 16),
          new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.1,
            clearcoat: 1.0,
            emissive: 0xffffff,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.9
          })
        );
        
        dot.position.set(dotPos.x, dotPos.y, dotPos.z);
        dot.userData = { id: dotPos.id, originalPosition: dot.position.clone() };
        dot.castShadow = true;
        
        // Add a subtle glow
        const glowGeometry = new THREE.SphereGeometry(0.04, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.2
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        dot.add(glow);
        
        scene.add(dot);
        dots.push(dot);
      });
    }

    function createTextTexture(text, fontSize = 32, color = '#ffffff') {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      
      context.fillStyle = 'rgba(0,0,0,0.7)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      context.strokeStyle = 'rgba(255,255,255,0.3)';
      context.lineWidth = 2;
      context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      
      context.fillStyle = color;
      context.font = `bold ${fontSize}px Arial`;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    function create3DUI() {
      instructionPanel = new THREE.Group();
      instructionPanel.position.set(0, 1.0, -1.2); // Lowered from 2.2 to 1.0
      
      const instructionTexture = createTextTexture('Connect the dots in order!', 28, '#ffff00');
      const instructionGeometry = new THREE.PlaneGeometry(1.8, 0.4);
      const instructionMaterial = new THREE.MeshBasicMaterial({ 
        map: instructionTexture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      const instructionMesh = new THREE.Mesh(instructionGeometry, instructionMaterial);
      instructionPanel.add(instructionMesh);
      
      // Progress text
      const progressTexture = createTextTexture('Progress: 0/18 connections', 24, '#00ff88');
      const progressGeometry = new THREE.PlaneGeometry(1.6, 0.3);
      const progressMaterial = new THREE.MeshBasicMaterial({ 
        map: progressTexture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      progressText = new THREE.Mesh(progressGeometry, progressMaterial);
      progressText.position.y = -0.5;
      instructionPanel.add(progressText);
      
      scene.add(instructionPanel);
    }

    function updateProgressText() {
      if (!progressText) return;
      
      const progress = `Progress: ${connectedDots.length}/${connectionOrder.length} connections`;
      progressText.material.map = createTextTexture(progress, 24, '#00ff88');
      progressText.material.map.needsUpdate = true;
    }

    function setupController(session) {
      controllers = [];
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.addEventListener('connected', e => console.log(`Controller ${i} connected: ${e.data.handedness}`));
        controller.addEventListener('selectstart', () => handleControllerSelect(i));
        
        scene.add(controller);
        
        const controllerGroup = new THREE.Group();
        const controllerMesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.02, 16, 16),
          new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.1,
            emissive: 0xffffff,
            emissiveIntensity: 0.3
          })
        );
        controllerGroup.add(controllerMesh);
        controller.add(controllerGroup);
        
        if (i === 1) {
          controllerGroup.visible = false;
        }
        
        controllers.push(controller);
      }
      
      activeController = controllers[0];
      activeControllerIndex = 0;
    }

    function handleControllerSelect(controllerIndex) {
      if (gameComplete) return;
      
      const controller = controllers[controllerIndex];
      const intersectedDot = getIntersectedDot(controller);
      
      if (intersectedDot) {
        const expectedDotId = connectionOrder[currentDotIndex];
        
        if (intersectedDot.userData.id === expectedDotId) {
          // Correct dot!
          connectDot(intersectedDot);
          playConnectSound();
          
          currentDotIndex++;
          
          if (currentDotIndex >= connectionOrder.length) {
            completeGame();
          }
        } else {
          // Wrong dot - visual feedback
          flashDot(intersectedDot, 0xff0000);
        }
      }
    }

    function getIntersectedDot(controller) {
      const raycaster = new THREE.Raycaster();
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      const intersects = raycaster.intersectObjects(dots);
      return intersects.length > 0 ? intersects[0].object : null;
    }

    function connectDot(dot) {
      // Change dot color to green
      dot.material.color.set(0x00ff00);
      dot.material.emissive.set(0x006600);
      
      // Add to connected dots
      connectedDots.push(dot);
      
      // Draw line to previous dot if exists
      if (connectedDots.length > 1) {
        const previousDot = connectedDots[connectedDots.length - 2];
        drawLine(previousDot.position, dot.position);
      }
      
      updateProgressText();
      
      // Particle effect
      createConnectEffect(dot.position);
    }

    function drawLine(start, end) {
      const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
      const material = new THREE.LineBasicMaterial({
        color: 0x00ff88,
        linewidth: 3,
        transparent: true,
        opacity: 0.8
      });
      
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      lines.push(line);
    }

    function flashDot(dot, color) {
      const originalColor = dot.material.color.clone();
      const originalEmissive = dot.material.emissive.clone();
      
      dot.material.color.set(color);
      dot.material.emissive.set(color);
      
      setTimeout(() => {
        dot.material.color.copy(originalColor);
        dot.material.emissive.copy(originalEmissive);
      }, 300);
    }

    function createConnectEffect(position) {
      for (let i = 0; i < 10; i++) {
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.01, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.8
          })
        );
        
        particle.position.copy(position);
        particle.position.add(new THREE.Vector3(
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1
        ));
        
        scene.add(particle);
        
        // Animate particle
        const startTime = Date.now();
        const animate = () => {
          const elapsed = Date.now() - startTime;
          if (elapsed > 1000) {
            scene.remove(particle);
            return;
          }
          
          particle.material.opacity = 0.8 * (1 - elapsed / 1000);
          particle.position.y += 0.001;
          requestAnimationFrame(animate);
        };
        animate();
      }
    }

    function completeGame() {
      gameComplete = true;
      playCompleteSound();
      
      // Hide instruction panel
      if (instructionPanel) {
        instructionPanel.visible = false;
      }
      
      // Create the final Christmas tree
      createChristmasTree();
      
      updateStatus('Amazing! You walked freely and created a beautiful Christmas tree!');
    }

    function createChristmasTree() {
      christmasTree = new THREE.Group();
      
      // Tree levels with different colors
      const treeColors = [0x228B22, 0x32CD32, 0x00FF00];
      
      // Create tree sections
      for (let level = 0; level < 3; level++) {
        const geometry = new THREE.ConeGeometry(0.15 + level * 0.1, 0.3, 8);
        const material = new THREE.MeshPhysicalMaterial({
          color: treeColors[level],
          roughness: 0.3,
          metalness: 0.1,
          clearcoat: 0.5
        });
        
        const treePart = new THREE.Mesh(geometry, material);
        treePart.position.y = 1.0 - level * 0.2; // Adjusted for new scale
        treePart.castShadow = true;
        treePart.receiveShadow = true;
        christmasTree.add(treePart);
      }
      
      // Star on top
      const starGeometry = new THREE.ConeGeometry(0.05, 0.1, 5);
      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFD700,
        emissive: 0xFFD700,
        emissiveIntensity: 0.5
      });
      const star = new THREE.Mesh(starGeometry, starMaterial);
      star.position.y = 1.6; // Adjusted for new scale
      star.rotation.y = Math.PI;
      christmasTree.add(star);
      
      // Trunk
      const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2);
      const trunkMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x8B4513,
        roughness: 0.8,
        metalness: 0.1
      });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 0.3; // Adjusted for new scale
      trunk.castShadow = true;
      christmasTree.add(trunk);
      
      // Add some ornaments
      for (let i = 0; i < 8; i++) {
        const ornament = new THREE.Mesh(
          new THREE.SphereGeometry(0.02, 8, 8),
          new THREE.MeshPhysicalMaterial({
            color: Math.random() > 0.5 ? 0xFF0000 : 0x0000FF,
            roughness: 0.1,
            metalness: 0.8,
            emissive: Math.random() > 0.5 ? 0xFF0000 : 0x0000FF,
            emissiveIntensity: 0.2
          })
        );
        
        const angle = (i / 8) * Math.PI * 2;
        const radius = 0.1 + Math.random() * 0.1;
        const height = 0.5 + Math.random() * 0.8; // Adjusted for new scale
        
        ornament.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );
        christmasTree.add(ornament);
      }
      
      christmasTree.position.set(0, -0.8, -1.2); // Lowered and brought closer
      christmasTree.scale.setScalar(0.6); // Slightly smaller for better fit
      scene.add(christmasTree);
      
      // Animate the tree appearing
      christmasTree.scale.setScalar(0);
      const startTime = Date.now();
      const animateTree = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / 2000, 1);
        
        christmasTree.scale.setScalar(0.6 * progress); // Updated to match new scale
        christmasTree.rotation.y = progress * Math.PI * 2;
        
        if (progress < 1) {
          requestAnimationFrame(animateTree);
        }
      };
      animateTree();
    }

    function playConnectSound() {
      const audio = document.getElementById('connect-sound');
      audio.currentTime = 0;
      audio.play().catch(err => console.warn('Audio play failed:', err));
    }

    function playCompleteSound() {
      const audio = document.getElementById('complete-sound');
      audio.currentTime = 0;
      audio.play().catch(err => console.warn('Audio play failed:', err));
    }

    function render(time, frame) {
      if (frame) {
        // Animate dots
        const elapsedTime = clock.getElapsedTime();
        dots.forEach((dot, index) => {
          if (!connectedDots.includes(dot)) {
            // Gentle floating animation for unconnected dots
            dot.position.y = dot.userData.originalPosition.y + Math.sin(elapsedTime * 2 + index) * 0.02;
            
            // Gentle pulsing glow
            const glow = dot.children[0];
            if (glow) {
              glow.material.opacity = 0.2 + Math.sin(elapsedTime * 3 + index) * 0.1;
            }
          }
        });
        
        // Animate Christmas tree if complete
        if (christmasTree && gameComplete) {
          christmasTree.rotation.y += 0.005;
          
          // Animate ornaments
          christmasTree.children.forEach((child, index) => {
            if (child.material && child.material.emissive) {
              child.material.emissiveIntensity = 0.2 + Math.sin(elapsedTime * 4 + index) * 0.1;
            }
          });
        }
      }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
